{
  "name": "Scientific-computing",
  "tagline": "Resources for the Leeds Scientific Computing seminar series",
  "body": "#Example Data Analysis from ArrayExpress in R\r\n\r\nThis is a summary of the data analysis Scientific Computation workshop held in St. James's Campus on May 17, 2016.\r\n\r\nThe aim of this session is to demonstrate how you might get a specific dataset online (along with its associated metadata), load it into R, and then perform a simple A--B statistical test on it.\r\n\r\n##Download the Data\r\nFirst, we need to download some data from ArrayExpress. For this session, we'll use the Melanoma cohort data produced in Prof. Bishop's group and submitted by Jeremie Nsengimana. It has the acccession number [E-MTAB-4725](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-4725/).\r\n\r\nWe need both the processed data and sample mapping from Jeremie's Melanoma dataset. Either you can use the website to download the files, or you can use the following in the terminal. (NB: You might not have the necessary command `curl` installed.)\r\n\r\n~~~bash\r\ncurl https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-4725/E-MTAB-4725.processed.1.zip > E-MTAB-4725.processed.1.zip\r\ncurl https://www.ebi.ac.uk/arrayexpress/files/E-MTAB-4725/E-MTAB-4725.sdrf.txt > E-MTAB-4725.sdrf.txt\r\n~~~\r\n\r\nOnce you have the data file (`E-MTAB-4725.processed.1.zip`) and the Sample-Data Relationship File (SDRF file) (`E-MTAB-4725.sdrf.txt`), you need to unzip the data. You can double-click on the file, or you can use the terminal:\r\n\r\n~~~bash\r\nunzip E-MTAB-4725.processed.1.zip\r\n~~~\r\n\r\nAt this point, you should have two downloaded files: a processed expression file `LMC204primaries_wgdaslHT12.4gx.txt` and a metadata file `E-MTAB-4725.sdrf.txt`.\r\n\r\n##Explore the Downloaded Data\r\nBefore using R, we should see what we have downloaded. As the files are quite big, we'll do this in the terminal (rather than in a text editor, or Excel).\r\n\r\n~~~bash\r\nwc -l ./LMC204primaries_wgdaslHT12.4gx.txt # How many lines are in the data file?\r\nwc -l ./E-MTAB-4725.sdrf.txt # How many lines are in the metadata file?\r\nhead ./LMC204primaries_wgdaslHT12.4gx.txt # Show the first few lines of the data file\r\nhead ./E-MTAB-4725.sdrf.txt # Show the first few lines of the metadata file\r\n~~~\r\n\r\nLooking closely at what we have, we can see that our data file contains a header line, followed by many (well, 29354 - 1 = 29353) data lines. Each data line consists of a probe ID, a gene name, then 204 individual sample expression values.\r\n\r\nThe metadata consists of a header line followed by 204 lines, each of which consists of multiple bits of information about that sample.\r\n\r\n##Load the Data into R\r\nNow we know our data have a header row and row names, we can load them into R. Fire up R, and make sure that you've set R to the same directory that contains your two data files. Remember that you can move around the file hierarchy from within R using:\r\n\r\n~~~r\r\ngetwd() # Where am I now?\r\ngetwd(\"new_dir\") # Go into a new directory\r\nlist.files() # Show the files in the current diretory\r\n~~~\r\n\r\nFirst, we need to load the expression data:\r\n\r\n~~~r\r\nd <- read.table(\"LMC204primaries_wgdaslHT12.4gx.txt\", sep=\"\\t\", header=TRUE, row.names=1)\r\n~~~\r\n\r\nThis command tells R to:\r\n\r\n1. Read in the file `LMC204primaries_wgdaslHT12.4gx.txt`;\r\n2. Assume that each column is separated by tab characters (`sep=\"\\t\"`);\r\n3. Treat the first row of data as column headers (`header=TRUE`);\r\n4. Treat the first column of data are row names (`row.names=1`); and finally\r\n5. Save the resulting `data.frame` to a variable called `d`.\r\n\r\nSimilarly, we can load in the metadata:\r\n\r\n~~~r\r\nmetadata <- read.table(\"E-MTAB-4725.sdrf.txt\", sep=\"\\t\", header=TRUE, row.names=1)\r\n~~~\r\n\r\n###Preprocess the Data\r\nNow that we have loaded the data, we need to do several things to it to make working with it easier. The first thing we need to do is to pull out the gene ID column from `d`, as it will get in the way, and is preventing us making the expression data into a matrix. There are multiple ways of getting a single column from a `data.frame`, but however we decide to get the `GENE` column, we need to make sure it has names. We assign it names based on the rownames of d (where it came from), and finally remove the `GENE` column from `d`. After this, we can make d into a `matrix`: \r\n\r\n~~~r\r\n# NB: All three of these commands do the same thing!\r\ngenes <- d[,1] # Pull out the first column and save it as a vector to the variable `genes`.\r\ngenes <- d[,\"GENE\"] # Pull out the column with the name `GENE` and save it as a vector to the variable `genes`.\r\ngenes <- d$GENE # Pull out the column with the name `GENE` and save it as a vector to the variable `genes`.\r\n\r\nnames(genes) <- rownames(d) # Assign names to the vector genes.\r\nd$GENE <- NULL # Remove the GENE column from d.\r\n\r\nd <- as.matrix(d) # Make d into a matrix.\r\nclass(d) # Check that it is a matrix.\r\n~~~\r\n\r\n###Preprocess the Metadata\r\nWe need to define two groups of samples in order to perform a simple statistical test. In this case, we'll use the sample gender although you will of course use more sensible clinical variables to assign your groups. Whatever we choose to look at, we need to make sure that the data and metadata datasets match. To do this, we'll first perform some sanity checks to make sure that we have metadata corresponding to our data, and *visa versa*:\r\n\r\n~~~r\r\ncolnames(d) # What are the sample names in our data?\r\nrownames(metadata) # What are the sample names in our metadata?\r\nncol(d) # How many sample columns do we have in our data?\r\nnrow(metadata) # How many sample rows do we have in the metadata?\r\nlength(intersect(colnames(d), rownames(metadata))) # What is the size of the intersection between our data and metadata samples?\r\nlength(setdiff(colnames(d), rownames(metadata))) # How many samples are in our data but not in our metadata?\r\nlength(setdiff(rownames(metadata), colnames(d))) # How many samples are in our metadata but not in our data?\r\n~~~\r\n\r\nThis has shown us that we have 204 samples, and that we have the same IDs in both our data and metadata. Now, we are in a position to extract a variable of interest to use when selecting our two groups. Here we'll use the patient gender. As the column names are extracted by R from the input text file, and have been stripped of any illegal characters, they might look a little odd:\r\n\r\n~~~r\r\ngender <- metadata[,\"Characteristics.sex.\"] # Extract the metadata column \"Characteristics.sex.\" and call it gender.\r\ngender <- factor(gender) # Make gender a factor, not a vector of strings.\r\nnames(gender) <- rownames(metadata) # Assign names to gender from the metadata object it has just come from.\r\n~~~\r\n\r\n###Check that the Data Match\r\nAt this point, we are almost ready to run some tests.  However, we must make sure that the order of our columns in `d` is the same as the order of genders in `gender`. Otherwise, we are in danger of mixing up our metadata. To do this, we can simply subset `gender` by the column names of `d`. This works as we've assigned names to the `gender` vector:\r\n\r\n~~~r\r\ngender <- gender[colnames(d)] # Make sure that gender is in the correct order to be comparable to our data\r\nall(names(gender) == colnames(d)) # Check if all the names of gender match the corresponding column names in d.\r\n~~~\r\n\r\n##Statistical Testing\r\nAs a brief example, we're going to perform a t-test upon the first row of our data. To do this, we need to extract the expressions for the first probe for male patients and female patients separately. Then, we can use the `t.test` function to test if they come from the same background distribution:\r\n\r\n~~~r\r\nmale <- d[1, gender==\"male\"] # Select the first probe from d and all samples for which geneder is male\r\nfemale <- d[1, gender==\"female\"] # Select the first probe from d and all samples for which geneder is female\r\nt.test(female, male) # Perform a simple t-test between female and male\r\n~~~\r\n\r\nThis gives back something like:\r\n\r\n~~~\r\n\tWelch Two Sample t-test\r\n\r\ndata:  female and male\r\nt = 0.56901, df = 190.32, p-value = 0.57\r\nalternative hypothesis: true difference in means is not equal to 0\r\n95 percent confidence interval:\r\n -0.1000113  0.1811052\r\nsample estimates:\r\nmean of x mean of y \r\n 13.86714  13.82659 \r\n~~~\r\n\r\nFrom this, we can see that the first probe has about the same expressin mean in females and males (13.86714 vs 13.82659), and that the probability of seeing a difference this large (or larger) by chance is 0.57 (i.e. the *p*-value). So, we would not claim this probe was significantly different between our samples.\r\n\r\nIf we only want to test one row, this would be fine.  However, we have `nrow(d)` rows (29354) to test, so it would be unfeasibly slow to test each in turn like this. Luckily, we can use the `rowttests` function in the `genefilter` package. However to use it, we must make sure it is installed.\r\n\r\n###Installing the `genefilter` Package\r\nThe [`genefilter`](http://bioconductor.org/packages/release/bioc/html/genefilter.html) package is part of the [Bioconductor](http://bioconductor.org) project. Before attempting to install it, check if you already have it loaded:\r\n\r\n~~~r\r\nlibrary(genefilter) # Load the genefilter library\r\n~~~\r\n\r\nIf you get an error along the lines of `Error in library(genefilter) : there is no package called ‘genefilter’`, then you need to install it:\r\n\r\n~~~r\r\nsource(\"https://bioconductor.org/biocLite.R\")\r\nbiocLite(\"genefilter\")\r\nlibrary(genefilter)\r\n~~~\r\n\r\nWhen installing, you might be asked if you want to update other packages. For now, say `n`.\r\n\r\n###Using `rowttests`\r\nNow that we have the `genefilter` package loaded, we can run multiple t-tests at once. The `rowttests` function requires a matrix of data (in our case `d`), and a factor containing two levels that splits the columns of the data matrix into two groups (in our case `gender`). As we have these two things, we can now do a t-test for each row in turn:\r\n\r\n~~~r\r\nres <- rowttests(d, gender) # Perform a t.test on each row of the data.\r\nhead(res) # Look at the top of the results.\r\n~~~\r\n\r\nNotice that for the top gene, we get pretty much the same value. If we want the `t.test` results to be exactly the same as those from `rowttests`, we would have to tell `t.test` to assume equal variance for the two groups (using `var.equal=TRUE`), otherwise the tests will give very slightly different results. If your analysis requires non-equal variance, you need to be careful when using `rowttests`, as it assumes equal variance.\r\n\r\nAlthough we have now successfully generated *p*-values for each row in the input data, we need to add some extra data for this to become useful. First, we need to generate an adjusted *p*-value to take into account the fact that we have performed 29,354 individual tests, and thus some are likely to be significant by chance. Second, we need to add on the gene names to make the probe IDs meaningful. Last, we need to select our top hits.\r\n\r\n###Adjusting p Values\r\nLuckily, adjusting *p*-values in R is trivial, we can use the `p.adjust` function. All this needs is a vector of *p*-values, and it returns a vector of adjusted *p*-values. By default, it uses Benjamini & Hochberg correction (also called False Discovery Rate). We will create a new column in our results for the adjusted *p*-values:\r\n\r\n~~~r\r\nres$p.adjust <- p.adjust(res$p.value) # Add a new column of adjusted p-values to res.\r\n~~~\r\n\r\n###Annotating & Sorting the Results\r\nJust as we added a new column for the adjusted *p*-values, we can add the gene name annotations that we extracted from the data a while ago. As we assigned these names, we can easily add them onto our results by the rownames of `res`:\r\n\r\n~~~r\r\nres$gene <- genes[rownames(res)] # Add the gene names to res.\r\n~~~\r\n\r\nAt this point, we can extract only significant differences, and order our data by p-value:\r\n\r\n~~~r\r\nres.sel <- res[res$p.adjust <= 0.01,] # Extract only those probes with an adjusted p-value less than a threshold of 0.01.\r\nres.sel <- res.sel[order(res.sel$p.adjust),] # Use order to re-order the rows into decreasing order of adjusted p value.\r\n~~~\r\n\r\nAt this point, `res.sel` contains 31 annotated probes, each of which corresponds to a gene that has a significant difference (by *t*-test) between our two sample groups.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}